{"version":3,"sources":["../../../../units/urb-persister-elasticsearch/graphql/PersisterElasticSearch.js"],"names":["Uuid_Null","PersisterElasticSearch","constructor","stores","getStore","entityName","findIndexes","filter","store","arr_Indexes","objectInStore","index","filterMatched","filterField","push","findObjects","arr_Objects","map","getOneObject","ObjectType","filters","Promise","resolve","getObjectList","arr_arr_Objects","add","fields","newObject","update","newFields","id","an_Object","fieldName","remove","indexToDelete","splice","createLogger","uuidFromString","str","uuidRandom","uuidNull","uuidNullAsString","uuidToString","uuidEquals","id1","id2","addTableSchema","tableName","tableSchema","confirmHealth","reject","initialize","runAsPartOfSetupDatabase","cb"],"mappings":"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","file":"PersisterElasticSearch.js","sourcesContent":["// @flow\n\nconst Uuid_Null = '00000000-0000-0000-0000-000000000000'\n\nexport default class PersisterElasticSearch {\n  stores: Object\n\n  constructor() {\n    this.stores = {}\n  }\n\n  getStore( entityName: string ) {\n    if ( entityName in this.stores ) return this.stores[entityName]\n    else return ( this.stores[entityName] = [])\n  }\n\n  findIndexes( entityName: string, filter: Object ) {\n    const store = this.getStore( entityName )\n    const arr_Indexes = []\n\n    for ( let [ objectInStore, index ] of store ) {\n      let filterMatched = true\n      for ( let filterField in filter )\n        if ( objectInStore[filterField] !== filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if ( filterMatched ) arr_Indexes.push( index )\n    }\n\n    return arr_Indexes\n  }\n\n  findObjects( entityName: string, filter: Object ) {\n    const store = this.getStore( entityName )\n    const arr_Objects = []\n\n    store.map( objectInStore => {\n      let filterMatched = true\n      for ( let filterField in filter )\n        if ( objectInStore[filterField] !== filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if ( filterMatched ) arr_Objects.push( objectInStore )\n    })\n\n    return arr_Objects\n  }\n\n  getOneObject(\n    entityName: string,\n    ObjectType: any,\n    filters: Array<any>\n  ): Promise<any> {\n    const arr_Objects = filters.map(\n      filter => this.findObjects( entityName, filter )[0]\n    )\n    return Promise.resolve( arr_Objects )\n  }\n\n  getObjectList(\n    entityName: string,\n    ObjectType: any,\n    filters: Array<any>\n  ): Promise<Array<any>> {\n    const arr_arr_Objects = filters.map( filter =>\n      this.findObjects( entityName, filter )\n    )\n    return Promise.resolve( arr_arr_Objects )\n  }\n\n  add( entityName: string, fields: any, ObjectType: any ): Promise<any> {\n    const store = this.getStore( entityName )\n    const newObject = new ObjectType( fields )\n\n    store.push( newObject )\n\n    return Promise.resolve()\n  }\n\n  update( entityName: string, fields: any ): Promise<null> {\n    // Only use the ID to find the record to delete\n    const newFields = {}\n    newFields.id = fields.id\n\n    const an_Object = this.findObjects( entityName, newFields )[0]\n\n    for ( let fieldName in fields ) an_Object[fieldName] = fields[fieldName]\n\n    return Promise.resolve()\n  }\n\n  remove( entityName: string, fields: any ): Promise<null> {\n    const store = this.getStore( entityName )\n\n    const indexToDelete = this.findIndexes( entityName, fields )[0]\n    store.splice( indexToDelete, 1 )\n\n    return Promise.resolve()\n  }\n\n  createLogger() {\n    return null // No need for logger, by default it will output to console in dev mode\n  }\n\n  uuidFromString( str: string ): string {\n    return str\n  }\n\n  uuidRandom(): string {\n    return ''\n  }\n\n  uuidNull() {\n    return Uuid_Null\n  }\n\n  uuidNullAsString() {\n    return Uuid_Null\n  }\n\n  uuidToString( id: any ) {\n    // ids are always strings anyway\n    return id\n  }\n\n  uuidEquals( id1: any, id2: any ): boolean {\n    return id1 === id2\n  }\n\n  addTableSchema( tableName: string, tableSchema: Object ): void {\n    // Nothing to do, it's all in memory\n  }\n\n  confirmHealth(): Promise<null> {\n    return new Promise( ( resolve, reject ) => {\n      resolve()\n    })\n  }\n\n  initialize( runAsPartOfSetupDatabase: boolean, cb: Function ): void {\n    // Nothing to do, it's all in memory\n    cb()\n  }\n}\n"]}